export type ChallengeDifficulty = 'beginner' | 'intermediate' | 'advanced' | 'expert';

export interface Challenge {
  id: string;
  title: string;
  description: string;
  difficulty: ChallengeDifficulty;
  category: string;
  problem: string;
  testCases: Array<{
    input: any;
    output: any;
    description: string;
  }>;
  hints: string[];
  solution: string;
  baseXP: number;
  timeLimit?: number;
  prerequisites?: string[];
}

export const CHALLENGES: Challenge[] = [
  {id: 'var-01', title: 'Variable Declaration', description: 'Declare a variable and assign a value', difficulty: 'beginner', category: 'Variables', problem: `Crie uma variável chamada "name" e atribua o valor "Code Flow" a ela. Retorne a variável.`, testCases: [{input: undefined, output: 'Code Flow', description: 'Declare and return name variable'}], hints: ['Use const ou let para declarar variáveis', 'A variável deve ser atribuída antes de retornar'], solution: `const name = "Code Flow"; return name;`, baseXP: 10},
  {id: 'var-02', title: 'Number Operations', description: 'Perform basic arithmetic operations', difficulty: 'beginner', category: 'Variables', problem: `Crie uma função que recebe dois números (a, b) e retorna a soma deles.`, testCases: [{input: [5, 3], output: 8, description: '5 + 3 = 8'}, {input: [10, 20], output: 30, description: '10 + 20 = 30'}, {input: [0, 0], output: 0, description: '0 + 0 = 0'}], hints: ['Use o operador + para somar', 'A função deve retornar o resultado'], solution: `function sum(a, b) { return a + b; }`, baseXP: 15},
  {id: 'var-03', title: 'String Concatenation', description: 'Combine strings together', difficulty: 'beginner', category: 'Variables', problem: `Crie uma função que recebe dois nomes (firstName, lastName) e retorna o nome completo combinado com um espaço.`, testCases: [{input: ['John', 'Doe'], output: 'John Doe', description: 'Combine John e Doe'}, {input: ['Jane', 'Smith'], output: 'Jane Smith', description: 'Combine Jane e Smith'}], hints: ['Use + para concatenar strings', 'Adicione um espaço entre os nomes'], solution: `function fullName(firstName, lastName) { return firstName + " " + lastName; }`, baseXP: 15},
  {id: 'cond-01', title: 'Simple If Statement', description: 'Check if a number is positive', difficulty: 'beginner', category: 'Conditionals', problem: `Crie uma função que retorna "positivo" se o número for maior que 0, caso contrário retorna "não positivo".`, testCases: [{input: [5], output: 'positivo', description: '5 é positivo'}, {input: [0], output: 'não positivo', description: '0 não é positivo'}, {input: [-3], output: 'não positivo', description: '-3 não é positivo'}], hints: ['Use if para checar se n > 0', 'Use else para o caso contrário'], solution: `function checkPositive(n) { return n > 0 ? "positivo" : "não positivo"; }`, baseXP: 20},
  {id: 'cond-02', title: 'Even or Odd', description: 'Determine if a number is even or odd', difficulty: 'beginner', category: 'Conditionals', problem: `Crie uma função que retorna "par" se o número é par, ou "ímpar" se for ímpar.`, testCases: [{input: [4], output: 'par', description: '4 é par'}, {input: [7], output: 'ímpar', description: '7 é ímpar'}, {input: [0], output: 'par', description: '0 é par'}], hints: ['Use o operador % (módulo) para checar o resto', 'Se n % 2 === 0, o número é par'], solution: `function evenOrOdd(n) { return n % 2 === 0 ? "par" : "ímpar"; }`, baseXP: 20},
  {id: 'loop-01', title: 'Count to N', description: 'Use a loop to count', difficulty: 'beginner', category: 'Loops', problem: `Crie uma função que retorna um array com números de 1 até n (inclusive).`, testCases: [{input: [3], output: [1, 2, 3], description: 'Count to 3'}, {input: [5], output: [1, 2, 3, 4, 5], description: 'Count to 5'}], hints: ['Use um loop for', 'Use .push() para adicionar números ao array'], solution: `function countToN(n) { const arr = []; for(let i = 1; i <= n; i++) arr.push(i); return arr; }`, baseXP: 25},
  {id: 'loop-02', title: 'Sum Array Elements', description: 'Calculate the sum of array elements', difficulty: 'beginner', category: 'Loops', problem: `Crie uma função que retorna a soma de todos os elementos em um array.`, testCases: [{input: [[1, 2, 3]], output: 6, description: 'Sum of [1, 2, 3]'}, {input: [[5, 10, 15]], output: 30, description: 'Sum of [5, 10, 15]'}, {input: [[0]], output: 0, description: 'Sum of [0]'}], hints: ['Comece com sum = 0', 'Use um loop para adicionar cada elemento'], solution: `function sumArray(arr) { let sum = 0; for(let i = 0; i < arr.length; i++) sum += arr[i]; return sum; }`, baseXP: 25},
  {id: 'arr-01', title: 'Find Maximum', description: 'Find the largest number in an array', difficulty: 'intermediate', category: 'Arrays', problem: `Crie uma função que retorna o maior número em um array.`, testCases: [{input: [[1, 5, 3, 9, 2]], output: 9, description: 'Max of [1, 5, 3, 9, 2]'}, {input: [[10]], output: 10, description: 'Max of [10]'}, {input: [[-5, -1, -10]], output: -1, description: 'Max of [-5, -1, -10]'}], hints: ['Comece com max = arr[0]', 'Compare cada elemento com o max'], solution: `function findMax(arr) { let max = arr[0]; for(let i = 1; i < arr.length; i++) if(arr[i] > max) max = arr[i]; return max; }`, baseXP: 35},
  {id: 'arr-02', title: 'Filter Even Numbers', description: 'Create an array with only even numbers', difficulty: 'intermediate', category: 'Arrays', problem: `Crie uma função que retorna um array contendo apenas os números pares.`, testCases: [{input: [[1, 2, 3, 4, 5, 6]], output: [2, 4, 6], description: 'Filter [1, 2, 3, 4, 5, 6]'}, {input: [[1, 3, 5]], output: [], description: 'No even numbers'}], hints: ['Use filter() ou crie um novo array', 'Verifique se cada número é par (n % 2 === 0)'], solution: `function filterEven(arr) { return arr.filter(n => n % 2 === 0); }`, baseXP: 40},
  {id: 'arr-03', title: 'Map to Squares', description: 'Create array with squared numbers', difficulty: 'intermediate', category: 'Arrays', problem: `Crie uma função que retorna um array com cada número elevado ao quadrado.`, testCases: [{input: [[1, 2, 3]], output: [1, 4, 9], description: 'Square [1, 2, 3]'}, {input: [[2, 4]], output: [4, 16], description: 'Square [2, 4]'}], hints: ['Use .map() ou um loop for', 'Multiplique cada número por si mesmo'], solution: `function mapToSquares(arr) { return arr.map(n => n * n); }`, baseXP: 40},
  {id: 'obj-01', title: 'Create User Object', description: 'Create an object with user properties', difficulty: 'intermediate', category: 'Objects', problem: `Crie uma função que recebe nome, idade e email e retorna um objeto com essas propriedades.`, testCases: [{input: ['John', 30, 'john@email.com'], output: {name: 'John', age: 30, email: 'john@email.com'}, description: 'Create user object'}], hints: ['Use const ou let para criar o objeto', 'Use chaves {} para definir as propriedades'], solution: `function createUser(name, age, email) { return { name, age, email }; }`, baseXP: 45},
  {id: 'obj-02', title: 'Object Property Access', description: 'Access and modify object properties', difficulty: 'intermediate', category: 'Objects', problem: `Crie uma função que recebe um objeto e retorna a propriedade "status" do objeto.`, testCases: [{input: [{status: 'active', id: 1}], output: 'active', description: 'Get status'}], hints: ['Use objeto.propriedade ou objeto["propriedade"]'], solution: `function getStatus(obj) { return obj.status; }`, baseXP: 35},
  {id: 'str-01', title: 'Reverse String', description: 'Reverse a string', difficulty: 'intermediate', category: 'Strings', problem: `Crie uma função que retorna a string invertida.`, testCases: [{input: ['hello'], output: 'olleh', description: 'Reverse hello'}, {input: ['abc'], output: 'cba', description: 'Reverse abc'}], hints: ['Use .split("") para converter em array', 'Use .reverse() para inverter', 'Use .join("") para converter de volta'], solution: `function reverseString(str) { return str.split("").reverse().join(""); }`, baseXP: 40},
  {id: 'str-02', title: 'Count Characters', description: 'Count specific character occurrences', difficulty: 'intermediate', category: 'Strings', problem: `Crie uma função que conta quantas vezes um caractere aparece em uma string.`, testCases: [{input: ['hello', 'l'], output: 2, description: 'Count l in hello'}, {input: ['mississippi', 's'], output: 4, description: 'Count s in mississippi'}], hints: ['Use um loop ou .split()', 'Compare cada caractere com o alvo'], solution: `function countChar(str, char) { let count = 0; for(let c of str) if(c === char) count++; return count; }`, baseXP: 40},
  {id: 'func-01', title: 'Higher Order Function', description: 'Create a function that returns a function', difficulty: 'advanced', category: 'Functions', problem: `Crie uma função que retorna uma função que adiciona um número n.`, testCases: [{input: [5], output: 8, description: 'addN(5)(3) = 8'}, {input: [10], output: 15, description: 'addN(10)(5) = 15'}], hints: ['A função deve retornar outra função', 'Use closures para acessar a variável n'], solution: `function addN(n) { return function(x) { return x + n; }; }`, baseXP: 55},
  {id: 'func-02', title: 'Compose Functions', description: 'Combine multiple functions', difficulty: 'advanced', category: 'Functions', problem: `Crie uma função que compõe duas funções f e g, retornando uma função que faz f(g(x)).`, testCases: [{input: [(x: number) => x * 2, (x: number) => x + 3, 5], output: 16, description: '(5 + 3) * 2 = 16'}], hints: ['Crie uma função que recebe duas funções', 'Retorne uma função que aplica g primeiro, depois f'], solution: `function compose(f, g) { return function(x) { return f(g(x)); }; }`, baseXP: 60},
  {id: 'rec-01', title: 'Factorial', description: 'Calculate factorial recursively', difficulty: 'advanced', category: 'Recursion', problem: `Crie uma função que calcula o fatorial de n recursivamente.`, testCases: [{input: [5], output: 120, description: '5! = 120'}, {input: [3], output: 6, description: '3! = 6'}, {input: [0], output: 1, description: '0! = 1'}], hints: ['Caso base: se n === 0 ou n === 1, retorne 1', 'Caso recursivo: retorne n * factorial(n - 1)'], solution: `function factorial(n) { if(n <= 1) return 1; return n * factorial(n - 1); }`, baseXP: 60},
  {id: 'rec-02', title: 'Fibonacci', description: 'Generate fibonacci sequence', difficulty: 'advanced', category: 'Recursion', problem: `Crie uma função que retorna o n-ésimo número de fibonacci.`, testCases: [{input: [6], output: 8, description: 'fib(6) = 8'}, {input: [7], output: 13, description: 'fib(7) = 13'}], hints: ['Caso base: fib(0) = 0, fib(1) = 1', 'Caso recursivo: fib(n) = fib(n-1) + fib(n-2)'], solution: `function fibonacci(n) { if(n <= 1) return n; return fibonacci(n-1) + fibonacci(n-2); }`, baseXP: 65},
  {id: 'alg-01', title: 'Binary Search', description: 'Implement binary search algorithm', difficulty: 'advanced', category: 'Algorithms', problem: `Crie uma função que realiza uma busca binária em um array ordenado e retorna o índice do alvo ou -1.`, testCases: [{input: [[1, 3, 5, 7, 9], 5], output: 2, description: 'Find 5 at index 2'}, {input: [[1, 3, 5, 7, 9], 1], output: 0, description: 'Find 1 at index 0'}, {input: [[1, 3, 5, 7, 9], 10], output: -1, description: 'Not found returns -1'}], hints: ['Mantenha left e right pointers', 'Calcule mid e compare com o alvo', 'Ajuste os pointers baseado na comparação'], solution: `function binarySearch(arr, target) { let left = 0, right = arr.length - 1; while(left <= right) { const mid = Math.floor((left + right) / 2); if(arr[mid] === target) return mid; if(arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }`, baseXP: 70},
  {id: 'ds-01', title: 'Flatten Nested Array', description: 'Flatten a deeply nested array', difficulty: 'advanced', category: 'Data Structures', problem: `Crie uma função que achata um array aninhado em uma única dimensão.`, testCases: [{input: [[1, [2, [3, 4]], 5]], output: [1, 2, 3, 4, 5], description: 'Flatten nested'}], hints: ['Use recursão ou um loop com pilha', 'Verifique se cada elemento é um array'], solution: `function flatten(arr) { return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatten(val) : val), []); }`, baseXP: 65},
  {id: 'exp-01', title: 'Longest Substring Without Repeat', description: 'Find longest substring without repeating characters', difficulty: 'expert', category: 'Strings', problem: `Crie uma função que retorna o comprimento da substring mais longa sem caracteres repetidos.`, testCases: [{input: ['abcabcbb'], output: 3, description: 'abc or bca or cab'}, {input: ['bbbbb'], output: 1, description: 'b'}, {input: ['pwwkew'], output: 3, description: 'wke'}], hints: ['Use uma janela deslizante (sliding window)', 'Mantenha um Set dos caracteres na janela atual', 'Expanda e contraia a janela conforme necessário'], solution: `function lengthOfLongestSubstring(s) { let max = 0, start = 0, charSet = new Set(); for(let i = 0; i < s.length; i++) { while(charSet.has(s[i])) charSet.delete(s[start++]); charSet.add(s[i]); max = Math.max(max, i - start + 1); } return max; }`, baseXP: 80},
  {id: 'exp-02', title: 'Merge Sorted Arrays', description: 'Merge two sorted arrays efficiently', difficulty: 'expert', category: 'Algorithms', problem: `Crie uma função que mescla dois arrays ordenados em um único array ordenado.`, testCases: [{input: [[1, 3, 5], [2, 4, 6]], output: [1, 2, 3, 4, 5, 6], description: 'Merge sorted arrays'}], hints: ['Use dois pointers, um para cada array', 'Compare e adicione o menor elemento'], solution: `function mergeSorted(arr1, arr2) { let result = []; let i = 0, j = 0; while(i < arr1.length && j < arr2.length) { result.push(arr1[i] < arr2[j] ? arr1[i++] : arr2[j++]); } return result.concat(arr1.slice(i)).concat(arr2.slice(j)); }`, baseXP: 85},
  {id: 'exp-03', title: 'Valid Parentheses', description: 'Check if parentheses are balanced', difficulty: 'expert', category: 'Data Structures', problem: `Crie uma função que verifica se os parênteses, colchetes e chaves são balanceados.`, testCases: [{input: ['()[]{}'], output: true, description: 'Valid'}, {input: ['([{}])'], output: true, description: 'Valid nested'}, {input: ['({)}'], output: false, description: 'Invalid order'}, {input: ['(]'], output: false, description: 'Mismatched'}], hints: ['Use uma pilha (stack)', 'Adicione abertura, remova quando fechar', 'Verifique se a pilha está vazia ao final'], solution: `function isValid(s) { const stack = []; const pairs = {'(': ')', '[': ']', '{': '}'}; for(let c of s) { if(pairs[c]) stack.push(c); else { if(stack.pop() !== Object.keys(pairs).find(k => pairs[k] === c)) return false; } } return stack.length === 0; }`, baseXP: 90},
  {id: 'arr-04', title: 'Remove Duplicates', description: 'Remove duplicate elements from array', difficulty: 'intermediate', category: 'Arrays', problem: `Crie uma função que remove elementos duplicados de um array.`, testCases: [{input: [[1, 2, 2, 3, 3, 3]], output: [1, 2, 3], description: 'Remove duplicates'}], hints: ['Use Set para rastrear únicos', 'Retorne um array novo'], solution: `function removeDuplicates(arr) { return [...new Set(arr)]; }`, baseXP: 40},
  {id: 'str-03', title: 'Palindrome Check', description: 'Check if string is a palindrome', difficulty: 'intermediate', category: 'Strings', problem: `Crie uma função que verifica se uma string é um palíndromo.`, testCases: [{input: ['racecar'], output: true, description: 'Is palindrome'}, {input: ['hello'], output: false, description: 'Not palindrome'}], hints: ['Compare a string com sua versão invertida'], solution: `function isPalindrome(str) { const reversed = str.split("").reverse().join(""); return str === reversed; }`, baseXP: 40},
  {id: 'cond-03', title: 'Grade Evaluator', description: 'Evaluate student grade', difficulty: 'beginner', category: 'Conditionals', problem: `Crie uma função que retorna a nota (A, B, C, D, F) baseada na pontuação (0-100).`, testCases: [{input: [90], output: 'A', description: '90+ = A'}, {input: [80], output: 'B', description: '80-89 = B'}, {input: [70], output: 'C', description: '70-79 = C'}], hints: ['Use if/else ou switch', '90+ = A, 80-89 = B, etc'], solution: `function getGrade(score) { if(score >= 90) return 'A'; if(score >= 80) return 'B'; if(score >= 70) return 'C'; if(score >= 60) return 'D'; return 'F'; }`, baseXP: 25},
  
  // More beginner challenges
  {id: 'var-04', title: 'Type Conversion', description: 'Convert between data types', difficulty: 'beginner', category: 'Variables', problem: `Crie uma função que recebe uma string numérica e retorna ela convertida para número.`, testCases: [{input: ['42'], output: 42, description: 'Convert "42" to 42'}, {input: ['100'], output: 100, description: 'Convert "100" to 100'}], hints: ['Use Number() ou parseInt()', 'Retorne o valor convertido'], solution: `function toNumber(str) { return Number(str); }`, baseXP: 15},
  {id: 'var-05', title: 'Boolean Logic', description: 'Work with boolean values', difficulty: 'beginner', category: 'Variables', problem: `Crie uma função que retorna true se ambos os parâmetros são true, caso contrário false.`, testCases: [{input: [true, true], output: true, description: 'Both true'}, {input: [true, false], output: false, description: 'One false'}, {input: [false, false], output: false, description: 'Both false'}], hints: ['Use o operador && (AND)', 'Retorne a comparação direta'], solution: `function andOperator(a, b) { return a && b; }`, baseXP: 15},
  {id: 'loop-03', title: 'Reverse Array', description: 'Reverse an array with a loop', difficulty: 'beginner', category: 'Loops', problem: `Crie uma função que inverte um array usando um loop (sem usar .reverse()).`, testCases: [{input: [[1, 2, 3]], output: [3, 2, 1], description: 'Reverse [1,2,3]'}, {input: [[5, 10, 15, 20]], output: [20, 15, 10, 5], description: 'Reverse [5,10,15,20]'}], hints: ['Itere de trás para frente', 'Use um novo array para armazenar'], solution: `function reverseArray(arr) { const result = []; for(let i = arr.length - 1; i >= 0; i--) result.push(arr[i]); return result; }`, baseXP: 25},
  
  // More intermediate challenges
  {id: 'arr-05', title: 'Array Intersection', description: 'Find common elements between arrays', difficulty: 'intermediate', category: 'Arrays', problem: `Crie uma função que retorna os elementos presentes em ambos os arrays.`, testCases: [{input: [[1, 2, 3], [2, 3, 4]], output: [2, 3], description: 'Intersection of [1,2,3] and [2,3,4]'}, {input: [[5, 6, 7], [7, 8, 9]], output: [7], description: 'Intersection with one common'}], hints: ['Use filter() para elementos do primeiro array', 'Verifique se o elemento existe no segundo array'], solution: `function intersection(arr1, arr2) { return arr1.filter(x => arr2.includes(x)); }`, baseXP: 45},
  {id: 'arr-06', title: 'Chunk Array', description: 'Split array into chunks', difficulty: 'intermediate', category: 'Arrays', problem: `Crie uma função que divide um array em sub-arrays de tamanho n.`, testCases: [{input: [[1, 2, 3, 4, 5], 2], output: [[1, 2], [3, 4], [5]], description: 'Chunk by 2'}, {input: [[1, 2, 3, 4, 5, 6], 3], output: [[1, 2, 3], [4, 5, 6]], description: 'Chunk by 3'}], hints: ['Use um loop e slice()', 'Incremente o índice pelo tamanho do chunk'], solution: `function chunk(arr, size) { const result = []; for(let i = 0; i < arr.length; i += size) result.push(arr.slice(i, i + size)); return result; }`, baseXP: 50},
  {id: 'obj-03', title: 'Object Merge', description: 'Merge two objects', difficulty: 'intermediate', category: 'Objects', problem: `Crie uma função que combina duas objetos em um novo objeto.`, testCases: [{input: [{a: 1}, {b: 2}], output: {a: 1, b: 2}, description: 'Merge two objects'}, {input: [{x: 10, y: 20}, {z: 30}], output: {x: 10, y: 20, z: 30}, description: 'Merge with multiple properties'}], hints: ['Use Object.assign() ou spread operator', 'Retorne um novo objeto'], solution: `function mergeObjects(obj1, obj2) { return {...obj1, ...obj2}; }`, baseXP: 40},
  {id: 'obj-04', title: 'Object Keys Count', description: 'Count object properties', difficulty: 'intermediate', category: 'Objects', problem: `Crie uma função que retorna o número de propriedades em um objeto.`, testCases: [{input: [{name: 'John', age: 30, city: 'NYC'}], output: 3, description: 'Count 3 properties'}, {input: [{}], output: 0, description: 'Empty object'}], hints: ['Use Object.keys() para obter as chaves', 'Retorne o length do array'], solution: `function countKeys(obj) { return Object.keys(obj).length; }`, baseXP: 35},
  {id: 'str-04', title: 'Capitalize Words', description: 'Capitalize first letter of each word', difficulty: 'intermediate', category: 'Strings', problem: `Crie uma função que capitaliza a primeira letra de cada palavra.`, testCases: [{input: ['hello world'], output: 'Hello World', description: 'Capitalize two words'}, {input: ['javascript is awesome'], output: 'Javascript Is Awesome', description: 'Capitalize multiple words'}], hints: ['Use split() para separar palavras', 'Capitalize cada palavra e junte com join()'], solution: `function capitalizeWords(str) { return str.split(' ').map(word => word[0].toUpperCase() + word.slice(1)).join(' '); }`, baseXP: 45},
  {id: 'str-05', title: 'Remove Whitespace', description: 'Remove all spaces from string', difficulty: 'intermediate', category: 'Strings', problem: `Crie uma função que remove todos os espaços de uma string.`, testCases: [{input: ['hello world'], output: 'helloworld', description: 'Remove spaces'}, {input: ['a b c d'], output: 'abcd', description: 'Remove multiple spaces'}], hints: ['Use replace() com regex', 'Use /\\s+/g para todos os espaços'], solution: `function removeSpaces(str) { return str.replace(/\\s+/g, ''); }`, baseXP: 40},
  {id: 'str-06', title: 'Find Longest Word', description: 'Find the longest word in a sentence', difficulty: 'intermediate', category: 'Strings', problem: `Crie uma função que retorna a palavra mais longa em uma frase.`, testCases: [{input: ['The quick brown fox'], output: 'quick', description: 'Find longest word'}, {input: ['JavaScript is amazing'], output: 'JavaScript', description: 'Find longest'}], hints: ['Use split() para separar palavras', 'Compare o length de cada palavra'], solution: `function longestWord(str) { return str.split(' ').reduce((longest, word) => word.length > longest.length ? word : longest, ''); }`, baseXP: 45},
  
  // More advanced challenges
  {id: 'func-03', title: 'Curry Function', description: 'Create a curried function', difficulty: 'advanced', category: 'Functions', problem: `Crie uma função curry que transforma uma função de múltiplos argumentos em funções de um argumento.`, testCases: [{input: [3], output: 6, description: 'curry(add)(1)(2)(3) = 6'}], hints: ['Retorne funções aninhadas', 'Cada função recebe um argumento e retorna outra função'], solution: `function curry(fn) { return function curried(...args) { if(args.length >= fn.length) return fn.apply(this, args); return (...args2) => curried.apply(this, args.concat(args2)); }; }`, baseXP: 70},
  {id: 'func-04', title: 'Debounce', description: 'Implement debounce function', difficulty: 'advanced', category: 'Functions', problem: `Crie uma função debounce que atrasa a execução de uma função.`, testCases: [{input: [100], output: true, description: 'Debounce executed after delay'}], hints: ['Use setTimeout para atrasar', 'Use clearTimeout para cancelar execuções anteriores'], solution: `function debounce(fn, delay) { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => fn.apply(this, args), delay); }; }`, baseXP: 70},
  {id: 'rec-03', title: 'Sum Nested Array', description: 'Sum all numbers in nested array', difficulty: 'advanced', category: 'Recursion', problem: `Crie uma função que soma todos os números em um array aninhado de qualquer profundidade.`, testCases: [{input: [[1, [2, [3, 4]], 5]], output: 15, description: 'Sum nested array'}, {input: [[10, [20, [30]]]], output: 60, description: 'Deep nesting'}], hints: ['Use recursão para processar cada elemento', 'Se o elemento é array, chame a função recursivamente'], solution: `function sumNested(arr) { return arr.reduce((sum, val) => sum + (Array.isArray(val) ? sumNested(val) : val), 0); }`, baseXP: 65},
  {id: 'rec-04', title: 'Tree Depth', description: 'Calculate depth of nested object', difficulty: 'advanced', category: 'Recursion', problem: `Crie uma função que calcula a profundidade máxima de um objeto aninhado.`, testCases: [{input: [{a: {b: {c: 1}}}], output: 3, description: 'Depth of 3'}, {input: [{x: 1}], output: 1, description: 'Depth of 1'}], hints: ['Use recursão para cada propriedade', 'Retorne 1 + max depth dos filhos'], solution: `function treeDepth(obj) { if(typeof obj !== 'object' || obj === null) return 0; return 1 + Math.max(0, ...Object.values(obj).map(treeDepth)); }`, baseXP: 70},
  {id: 'alg-02', title: 'Two Sum', description: 'Find two numbers that sum to target', difficulty: 'advanced', category: 'Algorithms', problem: `Crie uma função que encontra dois índices cujos valores somam ao target.`, testCases: [{input: [[2, 7, 11, 15], 9], output: [0, 1], description: '2 + 7 = 9'}, {input: [[3, 2, 4], 6], output: [1, 2], description: '2 + 4 = 6'}], hints: ['Use um Map para armazenar valores vistos', 'Para cada número, procure target - número'], solution: `function twoSum(arr, target) { const map = new Map(); for(let i = 0; i < arr.length; i++) { const complement = target - arr[i]; if(map.has(complement)) return [map.get(complement), i]; map.set(arr[i], i); } return []; }`, baseXP: 70},
  {id: 'alg-03', title: 'Bubble Sort', description: 'Implement bubble sort', difficulty: 'advanced', category: 'Algorithms', problem: `Crie uma função que ordena um array usando bubble sort.`, testCases: [{input: [[64, 34, 25, 12]], output: [12, 25, 34, 64], description: 'Sort array'}, {input: [[5, 1, 4, 2, 8]], output: [1, 2, 4, 5, 8], description: 'Sort unsorted'}], hints: ['Compare elementos adjacentes', 'Troque se estiverem fora de ordem', 'Repita até não haver mais trocas'], solution: `function bubbleSort(arr) { const result = [...arr]; for(let i = 0; i < result.length; i++) { for(let j = 0; j < result.length - i - 1; j++) { if(result[j] > result[j + 1]) [result[j], result[j + 1]] = [result[j + 1], result[j]]; } } return result; }`, baseXP: 65},
  {id: 'ds-02', title: 'Queue Implementation', description: 'Implement a queue data structure', difficulty: 'advanced', category: 'Data Structures', problem: `Crie uma classe Queue com métodos enqueue, dequeue e size.`, testCases: [{input: [1, 2, 3], output: 1, description: 'Dequeue returns first item'}], hints: ['Use um array para armazenar', 'enqueue adiciona no final', 'dequeue remove do início'], solution: `class Queue { constructor() { this.items = []; } enqueue(item) { this.items.push(item); } dequeue() { return this.items.shift(); } size() { return this.items.length; } }`, baseXP: 65},
  {id: 'ds-03', title: 'Stack Implementation', description: 'Implement a stack data structure', difficulty: 'advanced', category: 'Data Structures', problem: `Crie uma classe Stack com métodos push, pop, peek e isEmpty.`, testCases: [{input: [1, 2, 3], output: 3, description: 'Pop returns last item'}], hints: ['Use um array para armazenar', 'push adiciona no final', 'pop remove do final'], solution: `class Stack { constructor() { this.items = []; } push(item) { this.items.push(item); } pop() { return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } }`, baseXP: 65},
  
  // Expert challenges
  {id: 'exp-04', title: 'Anagram Groups', description: 'Group anagrams together', difficulty: 'expert', category: 'Strings', problem: `Crie uma função que agrupa palavras que são anagramas uma da outra.`, testCases: [{input: [['eat', 'tea', 'tan', 'ate', 'nat', 'bat']], output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']], description: 'Group anagrams'}], hints: ['Ordene as letras de cada palavra como chave', 'Use um Map para agrupar'], solution: `function groupAnagrams(words) { const map = new Map(); words.forEach(word => { const key = word.split('').sort().join(''); if(!map.has(key)) map.set(key, []); map.get(key).push(word); }); return Array.from(map.values()); }`, baseXP: 85},
  {id: 'exp-05', title: 'Median of Arrays', description: 'Find median of two sorted arrays', difficulty: 'expert', category: 'Algorithms', problem: `Crie uma função que encontra a mediana de dois arrays ordenados.`, testCases: [{input: [[1, 3], [2]], output: 2, description: 'Median is 2'}, {input: [[1, 2], [3, 4]], output: 2.5, description: 'Median is 2.5'}], hints: ['Merge os dois arrays', 'Encontre o elemento do meio', 'Se par, calcule a média dos dois do meio'], solution: `function findMedian(arr1, arr2) { const merged = [...arr1, ...arr2].sort((a, b) => a - b); const mid = Math.floor(merged.length / 2); return merged.length % 2 === 0 ? (merged[mid - 1] + merged[mid]) / 2 : merged[mid]; }`, baseXP: 90},
  {id: 'exp-06', title: 'LRU Cache', description: 'Implement Least Recently Used cache', difficulty: 'expert', category: 'Data Structures', problem: `Crie uma classe LRUCache que mantém um cache de tamanho limitado, removendo o item menos usado.`, testCases: [{input: [2], output: 1, description: 'Cache with capacity 2'}], hints: ['Use um Map para ordem de inserção', 'Ao acessar, mova para o final', 'Ao adicionar, remova o primeiro se cheio'], solution: `class LRUCache { constructor(capacity) { this.capacity = capacity; this.cache = new Map(); } get(key) { if(!this.cache.has(key)) return -1; const value = this.cache.get(key); this.cache.delete(key); this.cache.set(key, value); return value; } put(key, value) { if(this.cache.has(key)) this.cache.delete(key); else if(this.cache.size >= this.capacity) this.cache.delete(this.cache.keys().next().value); this.cache.set(key, value); } }`, baseXP: 95},
  {id: 'exp-07', title: 'Word Ladder', description: 'Find shortest transformation sequence', difficulty: 'expert', category: 'Algorithms', problem: `Crie uma função que encontra o caminho mais curto de transformação entre duas palavras, mudando uma letra por vez.`, testCases: [{input: ['hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']], output: 5, description: 'hit->hot->dot->dog->cog'}], hints: ['Use BFS (Breadth-First Search)', 'Tente trocar cada letra', 'Verifique se a palavra está no dicionário'], solution: `function ladderLength(begin, end, wordList) { if(!wordList.includes(end)) return 0; const queue = [[begin, 1]]; const visited = new Set([begin]); while(queue.length) { const [word, steps] = queue.shift(); if(word === end) return steps; for(let i = 0; i < word.length; i++) { for(let c = 97; c <= 122; c++) { const newWord = word.slice(0, i) + String.fromCharCode(c) + word.slice(i + 1); if(wordList.includes(newWord) && !visited.has(newWord)) { visited.add(newWord); queue.push([newWord, steps + 1]); } } } } return 0; }`, baseXP: 100},
  {id: 'exp-08', title: 'Trie Implementation', description: 'Implement a Trie (prefix tree)', difficulty: 'expert', category: 'Data Structures', problem: `Crie uma classe Trie com métodos insert, search e startsWith.`, testCases: [{input: ['apple'], output: true, description: 'Search inserted word'}], hints: ['Cada nó tem um Map de caracteres', 'Marque o fim das palavras', 'Navegue caractere por caractere'], solution: `class TrieNode { constructor() { this.children = new Map(); this.isEnd = false; } } class Trie { constructor() { this.root = new TrieNode(); } insert(word) { let node = this.root; for(let char of word) { if(!node.children.has(char)) node.children.set(char, new TrieNode()); node = node.children.get(char); } node.isEnd = true; } search(word) { let node = this.root; for(let char of word) { if(!node.children.has(char)) return false; node = node.children.get(char); } return node.isEnd; } startsWith(prefix) { let node = this.root; for(let char of prefix) { if(!node.children.has(char)) return false; node = node.children.get(char); } return true; } }`, baseXP: 100},
  {id: 'math-01', title: 'Prime Number Check', description: 'Check if a number is prime', difficulty: 'intermediate', category: 'Math', problem: `Crie uma função que verifica se um número é primo.`, testCases: [{input: [7], output: true, description: '7 is prime'}, {input: [10], output: false, description: '10 is not prime'}, {input: [2], output: true, description: '2 is prime'}], hints: ['Um número primo só é divisível por 1 e ele mesmo', 'Verifique divisores até a raiz quadrada'], solution: `function isPrime(n) { if(n <= 1) return false; if(n <= 3) return true; if(n % 2 === 0 || n % 3 === 0) return false; for(let i = 5; i * i <= n; i += 6) { if(n % i === 0 || n % (i + 2) === 0) return false; } return true; }`, baseXP: 50},
  {id: 'math-02', title: 'Greatest Common Divisor', description: 'Find GCD of two numbers', difficulty: 'intermediate', category: 'Math', problem: `Crie uma função que encontra o maior divisor comum (GCD) de dois números.`, testCases: [{input: [48, 18], output: 6, description: 'GCD of 48 and 18'}, {input: [100, 50], output: 50, description: 'GCD of 100 and 50'}], hints: ['Use o algoritmo de Euclides', 'GCD(a, b) = GCD(b, a % b)'], solution: `function gcd(a, b) { while(b !== 0) { const temp = b; b = a % b; a = temp; } return a; }`, baseXP: 45},
  {id: 'math-03', title: 'Power of Two', description: 'Check if number is power of 2', difficulty: 'intermediate', category: 'Math', problem: `Crie uma função que verifica se um número é potência de 2.`, testCases: [{input: [8], output: true, description: '8 = 2^3'}, {input: [16], output: true, description: '16 = 2^4'}, {input: [10], output: false, description: '10 is not power of 2'}], hints: ['Use operador bitwise', 'n & (n - 1) === 0 para potências de 2'], solution: `function isPowerOfTwo(n) { return n > 0 && (n & (n - 1)) === 0; }`, baseXP: 40},
  {id: 'perf-01', title: 'Unique Values', description: 'Count unique values in sorted array', difficulty: 'intermediate', category: 'Performance', problem: `Crie uma função que conta valores únicos em um array ordenado de forma eficiente.`, testCases: [{input: [[1, 1, 2, 3, 3, 4, 5, 5]], output: 5, description: 'Count 5 unique values'}, {input: [[1, 2, 3, 4, 5]], output: 5, description: 'All unique'}], hints: ['Use dois pointers', 'Compare elementos adjacentes'], solution: `function countUnique(arr) { if(arr.length === 0) return 0; let count = 1; for(let i = 1; i < arr.length; i++) { if(arr[i] !== arr[i - 1]) count++; } return count; }`, baseXP: 45},
  {id: 'data-01', title: 'Frequency Counter', description: 'Count frequency of elements', difficulty: 'intermediate', category: 'Data Manipulation', problem: `Crie uma função que retorna um objeto com a frequência de cada elemento no array.`, testCases: [{input: [[1, 2, 2, 3, 3, 3]], output: {1: 1, 2: 2, 3: 3}, description: 'Count frequencies'}, {input: [['a', 'b', 'a', 'c', 'b', 'a']], output: {a: 3, b: 2, c: 1}, description: 'Count string frequencies'}], hints: ['Use um objeto ou Map para contar', 'Incremente para cada ocorrência'], solution: `function frequencyCounter(arr) { const freq = {}; for(let item of arr) { freq[item] = (freq[item] || 0) + 1; } return freq; }`, baseXP: 45},
];

export function getBaseXP(difficulty: ChallengeDifficulty): number {
  const xpMap = { beginner: 20, intermediate: 45, advanced: 65, expert: 85 };
  return xpMap[difficulty];
}

export function getXPWithHint(baseXP: number, hintCount: number): number {
  return Math.max(Math.floor(baseXP * 0.7) - hintCount * 5, 5);
}

export function getXPWithSolution(baseXP: number): number {
  return Math.max(Math.floor(baseXP * 0.2), 2);
}

export function getDailyBonusXP(baseXP: number): number {
  return Math.floor(baseXP * 1.5);
}
